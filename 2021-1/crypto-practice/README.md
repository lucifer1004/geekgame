# 密码学实践

## Flag1

阅读源码，在Talk to Richard时，会输出两句话的加密结果。其中第二句话完全是明文，第一句话包含了未知的Flag。

继续研究`MESenc`函数。它是以32字节为单位对原始消息进行加密，对每一个部分的加密是相互独立的，同时使用的加密密钥是相同的。因此我们可以利用已有明文的第二句话还原出密钥，再用来解密第一句话的密文。注意这里我们不需要还原出完整的256字节的密钥，因为对于`[a, b, c, d]`这样的32字节，最后的加密结果就是`[k1 ^ c, k2 ^ d, k3 ^ a ^ c, k4 ^ b ^ d]`，所以我们计算出系数`k1`到`k4`即可。

还原得到Flag1为`flag{FE1SteL_neTw0rK_ne3d_an_OWF}`。

## Flag2

想要得到Flag2，需要在Talk to Richard时输入证书，并让自己的用户名被识别为`Alice`。但因为已经有了`Alice`的证书，我们无法直接以`Alice`为名去申请新的证书。研究证书的生成过程发现，证书是对`packed_name + packed_key`组成的`gmess`进行了一次RSA加密得到的，而加密的指数`d`未知，模数`n`在Talk to God时可以获取到。因为Richard并不管`key`的部分，同时`key`固定是128字节，`packed_key`固定是130位，所以我们只要想办法让改造`packed_name`就行。

对于`Alice`来说，`packed_name = Alice\x00\x05`，而我们希望取模结果保持不变，这里考虑给它加上`kn`，这里`k`是整数。我们需要枚举`k`，以使得得到的结果的最后两字节恰好对应于前面部分的长度。找到这样的`k`之后，我们就可以得到需要的伪造名称。至于`key`，随机生成一个128字节的串即可。

这样操作得到证书后，我们就可以通过Richard的校验，然后得到新的密文。注意到这段密文对应的明文的前32个字节是已知的，我们直接进行解密。

最后得到Flag2为`flag{RsA_1s_multIPlic4tivE_Hom0MorPHIc}`。
